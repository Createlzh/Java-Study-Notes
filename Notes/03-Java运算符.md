# Java运算符

- [运算符分类](#运算符分类)
- ​	[运算符优先级](#运算符优先级)
  - ​	[1.算数运算符](#1.算数运算符)
  - ​	[2.赋值运算符](#2.赋值运算符)
  - ​	[3.拓展赋值运算符](#3.拓展赋值运算符)
  - ​	[4.关系运算符](#4.关系运算符)
  - ​	[5.逻辑运算符](#5.逻辑运算符)
  - ​	[6.条件运算符](#6.条件运算符)
  - ​	[~~7.位运算符~~](#~~7.位运算符~~)
- [整数运算](#整数运算)
- [浮点数运算](#浮点数运算)
- [类型转换](#类型转换)

### 运算符分类

* 算术运算符 ：`+`，`-`，`*`，`/`，`%`，`++`（自增），`--`（自减）
* 赋值运算符 ：`=`
* 扩展赋值运算符：`+=`，`-=`，`*=`，`/=`
* 关系运算符：`>`，`<`，`>=`，`<=`，`==`，`!=`
* 逻辑运算符：`&`，`|`，   `&&`，`||`，`!`，`^`
* 位运算符： `&`，`|`，`^`，`~` ，`>>`，`<<`，`>>>` 
* 条件运算符：`? :`

>|          概念          |     示例      |
>| :--------------------: | :-----------: |
>| 运算符/操作符 Operator |       +       |
>|   表达式 Expression    |      5+6      |
>|     操作数 Operand     |      5 6      |
>|     语句 Sentence      | int m = 5+6 ; |

##### 运算符优先级

1. `()`
2. `!` `~` `++` `--`
3. `*` `/` `%`
4. `+` `-`
5. `<<` `>>` `>>>`
6. `&`
7. `|`
8. `+=` `-=` `*=` `/=`

##### 1.算数运算符

* `/`除法运算符，`%`求余运算符

* `+`表示正数，或相加操作，或字符串拼接

* `++` 在前表示先加1再运算；`++` 在后表示先运算再加1；

  ```java
  public class TestOpe04{
          public static void main(String[] args){
                  int a = 5;
                  a++;//理解为：相当于  a=a+1 操作  
                  System.out.println(a);//6
                  
                  a = 5;
                  ++a;//理解为：相当于  a=a+1 操作  
                  System.out.println(a); //6
                  
                  //总结：++单独使用的时候，无论放在前还是后，都是加1操作
                  
                  //将++参与到运算中：
                  //规则：看++在前还是在后，如果++在后：先运算，后加1   
              	//如果++在前，先加1，后运算
                  a = 5;
                  int m = a++ + 7;//先运算  m=a+7  再加1：  a = a+1 
                  System.out.println(m);//12
                  System.out.println(a);//6
                  
                  a = 5;
                  int n = ++a + 7;//先加1  a=a+1  再运算：  n = a+7 
                  System.out.println(n);//13
                  System.out.println(a);//6
              
              	a = 5;
              	System.out.println(a++ + a++); //5+6=11, a=7
              	System.out.println(a++ + ++a); //7+9=16, a=9
              
          }
  }
  ```

  > 注意`++` `--`的优先级高于`+`和`-`

##### 2.赋值运算符

> [两个数交换的四种方式](https://www.cnblogs.com/Brad-Lee/p/5808299.html "两个数的四种交换方式")

##### 3.拓展赋值运算符

> `a+=b`与`a=a+b`的区别:
>
> * a+=b    可读性稍差 编译效率高   **底层自动进行类型转换**
> * a=a+b     可读性好  编译效率低   **手动进行类型转换**

> `a+=b`相当于`a=a+b`,那么也相当于`a=b+a`吗:
>
> * 对基本数据类型来说，没有区别
> * 对String类型来说，结果的顺序不一样

> 下面哪一句代码出错？
>
> ```java
> byte a = 10; 
> int b = 20; 
> a+=b; 
> a = a+b; //应更正为 a = (byte)(a+b);
> ```

##### 4.关系运算符

关系运算符最终结果要么是`true`要么是`false`

##### 5.逻辑运算符

* 进行逻辑运算，运算符左右连接的都是布尔类型的操作数

* 逻辑运算符最终结果要么是`true`要么是`false`

  > |   名字   | 运算符号 |                     说明                     |
  > | :------: | :------: | :------------------------------------------: |
  > |  逻辑与  |    &     | 只要有一个操作数是false，那么结果一定是false |
  > |  逻辑或  |    \|    |  只要有一个操作数是true，那么结果一定是true  |
  > |  短路与  |    &&    |    只要第一个表达式是false，直接返回false    |
  > |  短路或  |   \|\|   |     只要第一个表达式为true，直接返回true     |
  > |  逻辑非  |    !     |                取反，相反结果                |
  > | 逻辑异或 |    ^     |     两个操作数相同则为false，不同为true      |

##### 6.条件运算符

* 又称**三元运算符**或**三目运算符**
* 格式为`a?b:c`
* 如果`a`的结果是true，那么只计算`b`，表达式最终结果为`b`
  如果`a`的结果是false，那么只计算`c`，表达式最终结果为`c`
* `b`和`c`的类型必须相同，因为返回值不是`boolean`，而是`b`和`c`之一
* 三目运算符可以替代`if-else`

##### ~~7.位运算符~~



____

### 整数运算

* **四则运算**

  * 可嵌套小括号，运算规则与初等数学一致
  * 整数的数值表示不但是精确的，而且整数运算永远是精确的
  * 除法也是精确的，因为两个整数相除只能得到结果的整数部分
  * 求余运算使用`%`
  * 特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错

  ```JAVA
  int x = 12345 / 67; // 184
  int y = 12345 % 67; // 12345÷67的余数是17
  ```

* **溢出**

  * 整数由于存在范围限制，如果计算结果超出了范围，就会产生`溢出`
  * 而溢出不会出错，却会得到一个奇怪的结果
  * 把`int`换成`long`类型，由于`long`可表示的整型范围更大，结果就不会溢出

  ```JAVA
  public class Main {
      public static void main(String[] args) {
          int x = 2147483640;
          int y = 15;
          int sum = x + y;
          System.out.println(sum); // -2147483641
          
          long x1 = 2147483640;
          long y1 = 15;
          long sum1 = x1 + y1;
          System.out.println(sum); // 2147483655
      }
  }
  ```

* **自增与自减**

  * Java还提供了`++`运算和`--`运算，它们可以对一个整数进行加1和减1的操作
  * `++n`表示先加1再引用n，`n++`表示先引用n再加1

  ```JAVA
  public class Main {
      public static void main(String[] args) {
          int n = 3300;
          n++; // 3301, 相当于 n = n + 1;
          n--; // 3300, 相当于 n = n - 1;
          int y = 100 + (++n); // 不要这么写
          System.out.println(y);
      }
  }
  ```

* **移位运算**

  >在计算机中，整数总是以二进制的形式表示。例如，`int`类型的整数`7`使用4字节表示的二进制如下：
  >
  >```java
  >00000000 0000000 0000000 00000111
  >```
  >
  >相应的可以对整数进行移位运算

  * 左移

  ```java
  int n = 7;       // 00000000 00000000 00000000 00000111 = 7
  int a = n << 1;  // 00000000 00000000 00000000 00001110 = 14
  int b = n << 2;  // 00000000 00000000 00000000 00011100 = 28
  int c = n << 28; // 01110000 00000000 00000000 00000000 = 1879048192
  int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912
  ```

  * 右移

  ```java
  int n = 7;       // 00000000 00000000 00000000 00000111 = 7
  int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
  int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
  int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
  ```

  >  如果对一个负数进行右移，最高位的`1`不动，结果仍然是一个负数

  ```java
  int n = -536870912;
  int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
  int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
  int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
  int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
  ```
  * 无符号右移

  > 使用`>>>`，它的特点是不管符号位，右移后高位总是补`0`
  >
  > 对一个负数进行`>>>`右移，它会变成正数，原因是最高位的`1`变成了`0`

  ```java
  int n = -536870912;
  int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
  int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
  int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
  int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
  ```

* **类型自动提升与强制转型**

  * 在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型

  ```java
  public class Main {
      public static void main(String[] args) {
          short s = 1234;
          int i = 123456;
          int x = s + i; // s自动转型为int
          short y = s + i; // 编译错误!
      }
  }
  ```

  * 可以将结果强制转型，即将大范围的整数转型为小范围的整数
  * 超出范围的强制转型会得到错误的结果

  ```java
  int i = 12345;
  short s = (short) i; // 12345
  int i1 = 1234567;
  short s1 = (short) i1; // -10617
  ```

  > 转型时，`int`的两个高位字节直接被扔掉，仅保留了低位的两个字节



___

### 浮点数运算

* 浮点数无法精确表示，运算会产生误差

  > 如浮点数`0.1`在计算机中就无法精确表示，因为十进制的`0.1`换算成二进制是一个无限循环小数。很显然，无论使用`float`还是`double`，都只能存储一个`0.1`的近似值。但是，`0.5`这个浮点数又可以精确地表示。

  > 比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：

  ```java
  // 比较x和y是否相等，先计算其差的绝对值:
  double r = Math.abs(x - y);
  // 再判断绝对值是否足够小:
  if (r < 0.00001) {
      // 可以认为相等
  } else {
      // 不相等
  }
  ```

* **溢出**

  整数运算在除数为`0`时会报错，而浮点数运算在除数为`0`时，不会报错，但会返回几个特殊值

  - `NaN`表示Not a Number
  - `Infinity`表示无穷大
  - `-Infinity`表示负无穷大

  ```java
  double d1 = 0.0 / 0; // NaN
  double d2 = 1.0 / 0; // Infinity
  double d3 = -1.0 / 0; // -Infinity
  ```

* **类型提升**

  * 如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型

  ```java
  public class Main {
      public static void main(String[] args) {
          int n = 5;
          double d = 1.2 + 24.0 / n; // 6.0
          System.out.println(d);
      }
  }
  ```

  * 需要特别注意，在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况

  ```java
  double d = 1.2 + 24 / 5; // 5.2
  ```

  > 计算结果为`5.2`，原因是编译器计算`24 / 5`这个子表达式时，按两个整数进行运算，结果仍为整数`4`

* **强制转型**

  * 可以将浮点数强制转型为整数，在转型时，浮点数的小数部分会被丢掉
  * 如果转型后超过了整型能表示的最大范围，将返回整型的最大值

  ```java
  int n1 = (int) 12.3; // 12
  int n2 = (int) 12.7; // 12
  int n2 = (int) -12.7; // -12
  int n3 = (int) (12.7 + 0.5); // 13
  int n4 = (int) 1.2e20; // 2147483647
  ```

  * 如果要进行四舍五入，可以对浮点数加上0.5再强制转型

  ```java
  public class Main {
      public static void main(String[] args) {
          double d = 2.6;
          int n = (int) (d + 0.5);
          System.out.println(n);
      }
  }
  ```




___

### 类型转换

> 在赋值运算或者算数运算的时候，要求数据类型一致，就要进行**类型转换**

* 种类：**自动转换**与**强制转化**

  ```java
  double d = 6;//int-->double  自动类型转换
  System.out.println(d);
  int i = (int)6.5;//double--->int  强制类型转换 （强转）
  System.out.println(i);
  ```

* 多种数据类型参与运算时，整数类型，浮点类型，字符类型都可以参与运算，唯独布尔类型不参与运算

  ```java
  double d2 = 12+1294L+8.5F+3.81+'a';
  System.out.println(d2);
  ```

* **类型级别（从低到高）**：

  `byte`,`short`,`char` > `int` > `long` > `float` > `double`

  > 在运算时，运算符的两边：
  >
  > 左=右  : 直接赋值
  > 左<右  ：强转
  > 左>右  ：直接自动转换

* 当一个表达式中有多种数据类型的时候，要找出当前表达式中级别最高的那个类型，然后其余的类型都转换为当前表达式中级别最高的类型进行计算

  ```java
  double d2 = 12+1294L+8.5F+3.81+'a';
  		//= 12.0+1294.0+8.5+3.81+97.0
  ```

  > [特殊情况](#浮点数运算)：参见**#浮点数运算**的**#类型提升**

  